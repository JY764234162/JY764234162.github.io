export default [
  {
    title: "js基本数据类型",
    content: `JavaScript 共有八种数据类型，分别是
  Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。
  其中 Symbol 和 BigInt 是 ES6 中新增的数据类型`,
  },
  {
    title: "let、const、var的区别",
    content: `1. let和const有暂时性死区，var没有
  2. let和const声明的变量具有块级作用域，var没有
  3. let和const不可以重复声明，var可以
  4. const赋值后不可以重新赋值，let和var可以重新赋值
  5. const必须有初始值、let和var不需要`,
  },

  {
    title: "数据类型检测的方式有",
    content: `1. typeof   除了null 的基本数据类型都能正确判断，复杂数据类型判断为object 
  2.  instanceof   可以正确判断对象的类型，原理是判断在其原型链中能否找到该类型的原型。 
  3.  constructor   原理是通过构造函数来进行判断
  4.  Object.prototype.toString.call   可以判断所有数据类型`,
  },

  {
    title: "null 和 undefined 区别 ",
    content: `undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回undefined，null 主要用于赋值给一些可能会返回对象的变量，作为初始化。 
  `,
  },

  {
    title: "判断一个对象为空对象的方式",
    content: `1.JSON.stringfy({})==='{}' （转化为字符串对比）
  
  2.Object.keys({}).length===0（获取对象的key数组的长度为0）
  
  3.Object.values({}).length===0 （获取对象的value数组的长度为0）
  
  4.Object.hasOwnProptyName({}).length===0（获取自身属性数组长度为0）
  
  5.使用for in循环遍历，在遍历里返回false，外部返回true`,
  },

  {
    title: "小程序与H5的区别",
    content: `运行环境方面
  从运行环境方面开看，H5 的宿主环境是浏览器，只要有浏览器，就可以使用，包括APP中的 web-view 组件，以及小程序提供的 web-view 组件
  小程序就不一样了，它运行于特定的移动软件平台 (Wechat / 支付宝 / 字节跳动 / 百度 / QQ 等)
  拿微信小程序来说，它是基于浏览器内核重构的内置解析器，它并不是一个完整的浏览器，官方文档中重点强调了脚本内无法使用浏览器中常用的 window 对象和 document 对象，就是没有 DOM 和 BOM 的相关的 API，这一条就干掉了 JQ 和一些依赖于 BOM 和 DOM 的NPM包
  运行机制方面
  H5 的运行就是一个网页的运行,小程序还是以微信小程序举例
  一.启动
  1.如果用户已经打开过某小程序，在一定时间内再次打开该小程序，此时无需重新启动，只需将后台的小程序切换到前台，整个过程就是所谓的 热启动
  2.如果用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，就是 冷启动
  二.销毁
  1.当小程序进入后台一定时间，或系统资源占用过高，或者是你手动销毁，才算真正的销毁
  系统权限方面
  H5最被诟病的地方在哪？系统权限不够，比如网络通信状态、数据缓存能力、通讯录、或调用硬件的，如蓝牙功能等等一些APP有的功能，H5就没有这些系统权限，因为它重度依赖浏览器能力
  依旧是微信小程序举例，微信客户端的这些系统级权限都可以和微信小程序无缝衔接，官方宣称拥有 Native App 的流畅性能
  开发语言方面
  H5 开发大家都知道，标准的 HTML、CSS、JavaScript ，万变不离其三剑客
  小程序不同， (Wechat / 支付宝 / 字节跳动 / 百度 / QQ 等)不同的小程序都有自己定义独特的语言
  最常用的微信小程序，自定义的 WXML、WXSS，WXML 中全部是微信自定义的标签，WXSS、JSON 和 JS 文件中的写法都稍有限制，官方文档中都有明确的使用介绍，虽容易上手，但还是有区别的
  开发成本方面
  还是先说 H5，开发一个 H5 ，我们要考虑什么，首先开发工具 ( vscode/webstorm/atom/sublim等 )，其次是开发框架 ( Vue/React/Angular等 )， 接着考虑模块化工具 ( Webpack/Gulp/Parcel等 )，再然后UI库、各种包的选择，更是数不胜数，还要考虑兼容问题，成本还是比较高的
  这块小程序的话不用再去考虑浏览器兼容性，拿微信小程序举例子，没有兼容性问题后，只需要看着文档在微信开发工具里写就行了，小程序还独立出来了很多原生APP的组件，在H5需要模拟才能实现的功能，小程序里可以直接调用组件，都是封装好的，你也可以使用转译框架来写小程序，也有很多UI库选择，单论开发成本的话，小程序应该是胜出的
  不过小程序再简单也是需要学习过程的，坑肯定也多，因为它还在逐步变强的过程中嘛，毕竟是和H5不一样的东西
  更新机制方面
  H5 的话想怎么更新就怎么更新，更新后抛开CDN/浏览器缓存啥的，基本上更新结束刷新就可以看到效果
  小程序不同，还是微信举例，微信小程序更新啥的是需要通过审核的
  而且开发者在发布新版本之后，无法立刻影响到所有现网用户，要在发布之后 24 小时之内才下发新版本信息到用户
  小程序每次 冷启动 时，都会检查有无更新版本，如果发现有新版本，会异步下载新版本代码包，并同时用客户端本地包进行启动，所以新版本的小程序需要等下一次 冷启动 才会应用上，当然微信也有 wx.getUpdateManager 可以做检查更新
  渲染机制方面
  H5就是 web 渲染，浏览器渲染
  微信小程序的宿主环境是微信，宿主环境为了执行小程序的各种文件：wxml文件、wxss文件、js文件，提供了双线模型 ，什么是双线程模型呢
  一.小程序的渲染层和逻辑层分别由2个线程管理
  1.渲染层：界面渲染相关的任务全都在 WebView 线程里执行，一个小程序存在多个界面，所以渲染层存在多个 WebView线程
  2.逻辑层：一个单独的线程执行 JavaScript，在这个环境下执行的都是有关小程序业务逻辑的代码，就是通过图中的 JsCore 线程来运行 JS 脚本
  3.这两个线程都会经过微信客户端( Native )中的 WeixinJsBridage 进行中转通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理二.小程序的渲染逻辑
  1.在渲染层将 WXML 先转换为 js 对象也就是虚拟 DOM
  2.在逻辑层将虚拟 DOM 对象生成真实 DOM 树，交给渲染层渲染
  3.当视图有数据需更新时，逻辑层调用小程序宿主环境提供的 setData 方法将数据从逻辑层传递到渲染层
  4.经过对比前后差异 ( diff算法 )，把差异应用在真实的 Dom`,
  },
];
